using System;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;
using System.Text;

namespace JPEG_Cs
{
    /// <summary>
    /// Представляет собой часть изображения, содержит один канал исходного изображения.
    /// </summary>
    public class Канал
    {
        /// <summary>
        /// Горизонтальный фактор масштабирования
        /// </summary>
        private int H;

        /// <summary>
        /// Вертикальный фактор масштабирования
        /// </summary>
        private int V;

        /// <summary>
        /// Массив, кторый хранит данные канала
        /// </summary>
        private МатрицаБайтов матрица;

        /// <summary>
        /// Создает канал на основе заданной матрицы
        /// </summary>
        /// <param name="матрица">Матрица, на основе которой создается Канал</param>
        public Канал(byte[,] матрица, int H, int V)
        {
            this.матрица = new МатрицаБайтов(матрица);
            this.H = H;
            this.V = V;
        }

	    /// <summary>
	    /// Создает экземпляр класса Канал путём объединения коллекции блоков в единую матрицу
        /// </summary>
        /// <param name="блоки"></param>
        /// <param name="ширинаМатрицы"></param>
        /// <param name="высотаМатрицы"></param>
        /// <param name="H">горизонтальный фактор масштабирования</param>
        /// <param name="V">вертикальный фактор масштабирования V</param>
        public Канал(List<Блок> блоки, int ширинаМатрицы, int высотаМатрицы, int H, int V)
        {
            this.H = H;
            this.V = V;
	        матрица = Преобразователь.ОбъединитьСписокБлоковВМатрицуБайтов(блоки, ширинаМатрицы, высотаМатрицы);
        }
        /// <summary>
        /// Меняет текущую матрицу дополняя значениями из последней колонки (по ширине) и последней строки (по высоте).
        /// Размеры матрицы становятся такие, что после уменьшения на Hmax/H и Vmax/V получаются размеры, кратные 8.
        /// </summary>
        /// <param name="Hmax"></param>
        /// <param name="Vmax"></param>
        public void Дополнение(int Hmax, int Vmax)
        {
            byte[,] временнаяМатрица = new byte [1,1];

            int высота = this.матрица.Высота;
            int ширина = this.матрица.Ширина;

            while (высота % (8 * (Hmax / H)) != 0)
                высота++;
            while (ширина % (8 * (Vmax / V)) != 0)
                ширина++;

            временнаяМатрица = new byte[ширина, высота];

            for (int i = 0; i < this.матрица.Ширина; i++)
                for (int j = 0; j < this.матрица.Высота; j++)
                    временнаяМатрица[i, j] = (byte)this.матрица.Элементы[i, j];

            for (int i = this.матрица.Ширина; i < временнаяМатрица.GetLength(0); i++)
                for(int j = 0; j < this.матрица.Высота; j++)
                    временнаяМатрица[i, j] = временнаяМатрица[i - 1, j];

            for (int i = this.матрица.Высота; i < временнаяМатрица.GetLength(1); i++)
                for (int j = 0; j < this.матрица.Ширина; j++)
                    временнаяМатрица[j, i] = временнаяМатрица[j, i - 1];

            МатрицаБайтов матрица = new МатрицаБайтов(временнаяМатрица);
            this.матрица = матрица;
        }


        /// <summary>
        /// Возвращает горизонтальный фактор масштабирования
        /// </summary>
        /// <returns></returns>
        public int ПолучитьH()
        {
            return H;
        }

        /// <summary>
        /// Возвращает вертикальный фактор мастабирования
        /// </summary>
        /// <returns></returns>
        public int ПолучитьV()
        {
            return V;
        }

        /// <summary>
        /// Возвращает матрицу, хранимую в экземпляре класса
        /// </summary>
        /// <returns></returns>
        public byte[,] ПолучитьМатрицу()
        {
            return матрица.Элементы;
        }

        /// <summary>
        /// Возвращает число, которое показывает, сколько блоков байтов указанной ширины
        /// будет содержать в ширину матрица канала, разделенная на эти блоки
        /// </summary>
        /// <param name="ширинаБлока"></param>
        /// <returns></returns>
        public int ПолучитьКоличествоБлоковПоШирине(int ширинаБлока)
        {
            return матрица.ПолучитьКоличествоБлоковПоШирине(ширинаБлока);
        }
        /// <summary>
        /// Возвращает число, которое показывает, сколько блоков байтов указанной высоты
        /// будет содержать в высоту матрица канала, разделенная на эти блоки
        /// </summary>
        /// <param name="высотаБлока"></param>
        /// <returns></returns>
        public int ПолучитьКоличествоБлоковПоВысоте(int высотаБлока)
        {
            return матрица.ПолучитьКоличествоБлоковПоВысоте(высотаБлока);
        }

        /// <summary>
        /// Преобразует исходную матрицу в новую, изменяя ширину и высоту. Значения матрицы интерполируются. 
        /// Новая ширина матрицы равна текущая ширина разделить на Hmax/H. Новая высота матрицы равна текущая высота разделить на Vmax/V. 
        /// Например, если H = 4, Hmax=4, то ширина не изменяется. H = 2, Hmax = 4, ширина уменьшается в 2 раза.
        /// </summary>
        /// <param name="Hmax">Горизонтальный фактор масштабирования</param>
        /// <param name="Vmax">Вертикальный фактор масшитабирования</param>
        public void Масштабирование(int Hmax, int Vmax)
        {
            // Элемент новой матрицы - среднее арифметическое элементов исходной матрицы,
            // заключенных в блоки размером Hmax / H на Vmax / V
            int ширинаБлока = Hmax / H;
            int высотаБлока = Vmax / V;
            Блок[,] матрицаБлоков = РазбитьМатрицуНаБлокиВФормеМатрицы(ширинаБлока, высотаБлока);
            int ширинаМасштабированнойМатрицы = матрицаБлоков.GetLength(0);
            int высотаМасштабированнойМатрицы = матрицаБлоков.GetLength(1);
            МатрицаБайтов масштабированнаяМатрица = new МатрицаБайтов(new byte[ширинаМасштабированнойМатрицы, высотаМасштабированнойМатрицы]);

            for (int j = 0; j < высотаМасштабированнойМатрицы; j++)
                for (int i = 0; i < ширинаМасштабированнойМатрицы; i++)
                    масштабированнаяМатрица.Элементы[i, j] = ПолучитьСреднееАрифметическоеЭлементовБлока(матрицаБлоков[i, j]);

            матрица = масштабированнаяМатрица;
        }

        private byte ПолучитьСреднееАрифметическоеЭлементовБлока(Блок блок)
        {
            byte[,] элементыБлока = блок.Элементы;
            int ширинаБлока = элементыБлока.GetLength(0);
            int высотаБлока = элементыБлока.GetLength(1);
            int количествоЭлементов = ширинаБлока * высотаБлока;
            int суммаЭлементов = 0;
            foreach(byte элемент in элементыБлока)
                суммаЭлементов += элемент;

            return (byte)Math.Round((double)суммаЭлементов / количествоЭлементов);
        }

        /// <summary>
        /// Преобразует исходную матрицу в новую, изменяя ширину и высоту. 
        /// Значения матрицы интерполируются. Новая ширина матрицы равна текущая ширина умножить на Hmax/H. 
        /// Новая высота матрицы равна текущая высота умножить на Vmax/V.
        /// </summary>
        /// <param name="Hmax">максимальное значение из всех значений H всех каналов</param>
        /// <param name="Vmax">максимальное значение из всех значений V всех каналов</param>
        /// <returns>Матрица, полученная в результате масштабирования</returns>
        public void ОбратноеМасштабирование(int Hmax, int Vmax)
        {
            // Строится матрица блоков, каждый блок которой соответствует элементу исходной матрицы
            // Блок байтов, размером Hmax / H на Vmax / V новой матрицы
            // Заполняется соответствующим элементом исходной матрицы
            int ширинаИсходнойМатрицы = матрица.Ширина;
            int высотаИсходнойМатрицы = матрица.Высота;
            int ширинаБлока = Hmax / H;
            int высотаБлока = Vmax / V;
            int ширинаМасштабированнойМатрицы = ширинаИсходнойМатрицы * ширинаБлока;
            int высотаМасштабированнойМатрицы = высотаИсходнойМатрицы * высотаБлока;

            Блок[,] МасштабированнаяМатрицаВВидеБлоков = new Блок[ширинаИсходнойМатрицы, высотаИсходнойМатрицы];
            for (int j = 0; j < высотаИсходнойМатрицы; j++)
                for (int i = 0; i < ширинаИсходнойМатрицы; i++)
                {
                    byte[,] блок = new byte[Hmax/H, Vmax/V];
                    Блок текущийБлок = new Блок(блок);
                    byte текущееЗначение = матрица.Элементы[i, j];
                    МасштабированнаяМатрицаВВидеБлоков[i, j] = ЗаполнитьВесьБлокОднимЗначением(текущийБлок, текущееЗначение);
                }

            List<Блок> списокБлоков = Преобразователь.ТрансформироватьМатрицуБлоковВСписокБлоков(МасштабированнаяМатрицаВВидеБлоков);
            МатрицаБайтов МасштабированнаяМатрица = Преобразователь.ОбъединитьСписокБлоковВМатрицуБайтов(списокБлоков, ширинаМасштабированнойМатрицы, высотаМасштабированнойМатрицы);
            матрица  = МасштабированнаяМатрица;
        }

        private Блок ЗаполнитьВесьБлокОднимЗначением(Блок блок, byte значение)
        {
            int ширинаБлока = блок.Элементы.GetLength(0);
            int высотаБлока = блок.Элементы.GetLength(1);
            for (int j = 0; j < высотаБлока; j++)
                for (int i = 0; i < ширинаБлока; i++)
                    блок.Элементы[i, j] = значение;

            return блок;
        }

        /// <summary>
        /// Разбивает матрицу на блоки указанного размера и возвращает полученные блоки в формате одномерного списка
        /// </summary>
        /// <param name="ширинаБлока"></param>
        /// <param name="высотаБлока"></param>
        /// <returns></returns>
        public List<Блок> РазбитьМатрицуНаБлокиВФормеСписка(int ширинаБлока, int высотаБлока)
        {
            РазбивательМатрицыНаБлоки разбиватель = new РазбивательМатрицыНаБлоки(матрица, ширинаБлока, высотаБлока);
            return разбиватель.ПолучитьБлокиВФормеСписка();

        }

        /// <summary>
        /// Разбивает матрицу на блоки указанного размера и возвращает полученные блоки в формате двумерного массивы (матрицы)
        /// </summary>
        /// <param name="ширинаБлока"></param>
        /// <param name="высотаБлока"></param>
        /// <returns></returns>
        public Блок[,] РазбитьМатрицуНаБлокиВФормеМатрицы(int ширинаБлока, int высотаБлока)
        {
            РазбивательМатрицыНаБлоки разбиватель = new РазбивательМатрицыНаБлоки(матрица, ширинаБлока, высотаБлока);
            return разбиватель.ПолучитьБлокиВФормеМатрицы();
        }

        public void Собрать(List<Блок> блоки, int HMax, int VMax)
        {
            byte[,] матрицаКанала = ПолучитьМатрицу();

            int НоваяШирина = матрица.Элементы.GetLength(0);
            int НоваяВысота = матрица.Элементы.GetLength(1);

            НоваяШирина /= HMax / H;
            НоваяВысота /= VMax / V;

            var временнаяМатрица = Преобразователь.ОбъединитьСписокБлоковВМатрицуБайтов(блоки, НоваяШирина, НоваяВысота);
            byte[,] m = new byte[НоваяШирина,НоваяВысота];
            this.матрица = new МатрицаБайтов(m);

            for (int j = 0; j < временнаяМатрица.Высота; j++)
                for (int i = 0; i < временнаяМатрица.Ширина; i++)
                    this.матрица.Элементы[i, j] = временнаяМатрица.Элементы[i, j];
        }
    }
}
