using System.Collections.Generic;
﻿using System;
using System.IO;

namespace JPEG_Cs
{
    public struct Точка
    {

        public byte r;
        public byte g;
        public byte b; 
        
        public Точка(byte r, byte g, byte b)
        {
            this.r = r;
            this.g = g;
            this.b = b;
        }
    }
    public enum Параметры 
    { 
        ВЫСОКОЕ_КАЧЕСТВО = 1 << 0, 
        СРЕДНЕЕ_КАЧЕСТВО = 1 << 1, 
        НИЗКОЕ_КАЧЕСТВО = 1 << 2, 
        ЭНТРОПИЙНОЕ_КАЧЕСТВО = 1 << 3 
    }
    public class JPEG_Cs
    {
        /// <summary>
        /// Создает объект класса из потока name
        /// </summary>
        /// <param name="name"></param>
        public JPEG_Cs(Stream name)
        {

        }

        /// <summary>
        /// Распаковывает содержимое JPEG файла, преобразует цвет кадра из YUV в RGB
        /// </summary>
        /// <returns>массив точек изображения в RGB</returns>
        public Точка[,] Распаковать()
        {
            Stream s = null;
            JPEGFile jPEGFile = new JPEGFile(s);
            Канал[] каналы = new Канал[3];
            каналы = jPEGFile.DecodeFrame();
            Точка[,] точки = new Точка[каналы[0].ПолучитьМатрицу().GetLength(0), каналы[0].ПолучитьМатрицу().GetLength(1)];

            for (int i = 0; i < каналы[0].ПолучитьМатрицу().GetLength(0); i++)
                for (int j = 0; j < каналы[0].ПолучитьМатрицу().GetLength(1); j++)
                {
                    byte[,] каналY = каналы[0].ПолучитьМатрицу();
                    точки[i, j].r = каналY[i, j];
                    byte[,] каналU = каналы[1].ПолучитьМатрицу();
                    точки[i, j].g = каналU[i, j];
                    byte[,] каналV = каналы[2].ПолучитьМатрицу();
                    точки[i, j].b = каналV[i, j];
                }

            for (int i = 0; i < каналы[0].ПолучитьМатрицу().GetLength(0); i++)
                for (int j = 0; j < каналы[0].ПолучитьМатрицу().GetLength(1); j++)
                {
                    double y = точки[i, j].r;
                    double u = точки[i, j].g;
                    double v = точки[i, j].b;

                    точки[i, j].r = (byte)(y + 1.4075 * (v - 128));
                    точки[i, j].g = (byte)(y - 0.3455 * (u - 128) - (0.7169 * (v - 128)));
                    точки[i, j].b = (byte)(y + 1.7790 * (u - 128));
                }
            return точки;
        }

        /// <summary>
        /// Сжимает изображение и записывает его в поток
        /// </summary>
        /// <param name="изображение"></param>
        public void Сжать(Точка[,] изображение)
        {

        }

        /// <summary>
        /// Возвращает ширину изображения
        /// </summary>
        /// <returns></returns>
        public int Ширина()
        {
            return 10;
        }

        /// <summary>
        /// Возвращает высоту изображения
        /// </summary>
        /// <returns></returns>
        public int Высота()
        {
            return 10;
        }

        /// <summary>
        /// Устанавливает параметры сжатия JPEG
        /// </summary>
        /// <param name="параметры"></param>
        public void ЗадатьПараметры(int параметры)
        {

        }

        /// <summary>
        /// Выполняется разбиение каналов на блоки 8x8 и перемешивание блоков в зависимости от значений факторов H и V в каналах
        /// </summary>
        /// <returns>Cписок блоков всех каналов в необходимом порядке</returns>
        public static List<Блок> Перемешивание(Канал[] каналы)
        {
            const int ШИРИНА_БЛОКА = 8;
            const int ВЫСОТА_БЛОКА = 8;
            int количествоКаналов = каналы.Length;
            if (количествоКаналов == 1)
                return каналы[0].РазбитьМатрицуНаБлокиВФормеСписка(ШИРИНА_БЛОКА, ВЫСОТА_БЛОКА);

            List<Блок> перемешанныеБлоки = new List<Блок>();
            List<Блок[,]> МатрицыБлоков = new List<Блок[,]>();
            int[] H = new int[количествоКаналов]; 
            int[] V = new int[количествоКаналов];
            for (int i = 0; i < количествоКаналов; i++)
            {
                var матрицаБлоковКанала = каналы[i].РазбитьМатрицуНаБлокиВФормеМатрицы(ШИРИНА_БЛОКА, ВЫСОТА_БЛОКА);
                МатрицыБлоков.Add(матрицаБлоковКанала);
                H[i] = каналы[i].ПолучитьH();
                V[i] = каналы[i].ПолучитьV();
            }
            // Макроблок - часть матрицы блоков размером H x V
            int количествоМакроблоковВШирину = каналы[0].ПолучитьКоличествоБлоковПоШирине(ШИРИНА_БЛОКА) / H[0];
            int количествоМакроблоковВВысоту = каналы[0].ПолучитьКоличествоБлоковПоВысоте(ВЫСОТА_БЛОКА) / V[0];
            // Перебор макроблоков
            for (int маркоблокПоВысоте = 0; маркоблокПоВысоте < количествоМакроблоковВВысоту; маркоблокПоВысоте++)
                for (int макроблокПоШирине = 0; макроблокПоШирине < количествоМакроблоковВШирину; макроблокПоШирине++)
                    for (int номерКанала = 0; номерКанала < количествоКаналов; номерКанала++)
                    {
                        // Обработка макроблока для каждого канала
                        int номерБлокаПоВысоте = 0;
                        while (номерБлокаПоВысоте < V[номерКанала])
                        {
                            int номерБлокаПоШирине = 0;
                            while (номерБлокаПоШирине < H[номерКанала])
                            {
                                int номерТекущегоБлокаШирине = макроблокПоШирине * H[номерКанала] + номерБлокаПоШирине;
                                int номерТекущегоБлокаПоВысоте = маркоблокПоВысоте * V[номерКанала] + номерБлокаПоВысоте;
                                Блок текущийБлок = МатрицыБлоков[номерКанала][номерТекущегоБлокаШирине, номерТекущегоБлокаПоВысоте];
                                перемешанныеБлоки.Add(текущийБлок);
                                номерБлокаПоШирине++;
                            }
                            номерБлокаПоВысоте++;
                        }
                    }

            return перемешанныеБлоки;
	    }

        /// <summary>
        /// Собирает блоки 8x8 в каналы. Если канал один, то все блоки записываются в канал слева-направо, сверху вниз.
        /// </summary>
        /// <param name="каналы">Каналы с пустыми матрицами, но с корректными шириной, высотой и значениями H и V</param>
        /// <param name="блоки">Список перемешанных блоков</param>
        public static void Собрать(Канал[] каналы, List<Блок> блоки)
        {
            const int ШИРИНА_БЛОКА = 8;
            const int ВЫСОТА_БЛОКА = 8;

            int количествоКаналов = каналы.Length;
            if (количествоКаналов == 1)
            {
                byte[,] матрицаКанала = каналы[0].ПолучитьМатрицу();
                var временнаяМатрица = Преобразователь.ОбъединитьСписокБлоковВМатрицуБайтов(блоки, матрицаКанала.GetLength(0), матрицаКанала.GetLength(1));
                for (int j = 0; j < временнаяМатрица.Высота; j++)
                    for (int i = 0; i < временнаяМатрица.Ширина; i++)
                        матрицаКанала[i, j] = временнаяМатрица.Элементы[i, j];
            }
            else
            {
                int[] H = new int[количествоКаналов];
                int[] V = new int[количествоКаналов];
                for (int i = 0; i < количествоКаналов; i++)
                {
                    H[i] = каналы[i].ПолучитьH();
                    V[i] = каналы[i].ПолучитьV();
                }
                int количествоМакроблоковВШирину = каналы[0].ПолучитьКоличествоБлоковПоШирине(ШИРИНА_БЛОКА) / H[0];
                int количествоМакроблоковВВысоту = каналы[0].ПолучитьКоличествоБлоковПоВысоте(ВЫСОТА_БЛОКА) / V[0];
                List<Блок>[] подспискиБлоков = new List<Блок>[количествоКаналов];
                int[] длинаЧастиПодсписка = new int[количествоКаналов];
                for (int i = 0; i < количествоКаналов; i++)
                    длинаЧастиПодсписка[i] = H[i] * V[i];

                int количествоЧастейПодсписка = количествоМакроблоковВШирину * количествоМакроблоковВВысоту;
                int номерТекущегоБлока = 0;
                for (int частьПодсписка = 0; частьПодсписка < количествоЧастейПодсписка; частьПодсписка++)
                    for (int номерКанала = 0; номерКанала < количествоКаналов; номерКанала++)
                    {
                        подспискиБлоков[номерКанала] = new List<Блок>();
                        for (int i = 0; i < длинаЧастиПодсписка[номерКанала]; i++)
                        {
                            Блок текущийБлок = блоки[номерТекущегоБлока];
                            подспискиБлоков[номерКанала].Add(текущийБлок);
                            номерТекущегоБлока++;
                        }
                    }

                for (int номерКанала = 0; номерКанала < количествоКаналов; номерКанала++)
                {
                    byte[,] матрицаКанала = каналы[номерКанала].ПолучитьМатрицу();
                    var временнаяМатрица = Преобразователь.ОбъединитьСписокБлоковВМатрицуБайтов(подспискиБлоков[номерКанала], матрицаКанала.GetLength(0), матрицаКанала.GetLength(1));
                    for (int j = 0; j < временнаяМатрица.Высота; j++)
                        for (int i = 0; i < временнаяМатрица.Ширина; i++)
                            матрицаКанала[i, j] = временнаяМатрица.Элементы[i, j];
                }
            }
        }

        /// <summary>
        /// Осуществляет все необходимые DCT преобразования для списка блоков: сдвиг уровней, FDCT, квантование, рассчет DC, зигзаг обход
        /// </summary>
        /// <param name="blocks">список блоков одного канала после разбиения на блоки</param>
        /// <returns>список коэффициентов блоков одного канала</returns>
        public List<short[]> FDCT(List<Блок> blocks, short[,] матрицаКвантования)
        {
            List<short[]> коэффициентыБлоков = new List<short[]>();
            List<short[,]> преобразованныеБлоки = new List<short[,]>();
            foreach (Блок block in blocks)
            {
                var блокПослеСдвигаУровней = DCT.СдвигУровней(block.Элементы);
                var блокПослеFDCT = DCT.FDCT(блокПослеСдвигаУровней);
                DCT.Квантование(блокПослеFDCT, матрицаКвантования);
                преобразованныеБлоки.Add(блокПослеFDCT);
            }
            //РасчетDC(преобразованныеБлоки);
            foreach (short[,] блок in преобразованныеБлоки)
            {
                коэффициентыБлоков.Add(DCT.Зигзаг(блок));
            }
            return коэффициентыБлоков;
        }

        /// <summary>
        /// Осуществляет все необходимые обратные DCT преобразования для списка блоков: сдвиг уровней, IDCT, обратное квантование, восстановление DC, обратный зигзаг обход
        /// </summary>
        /// <param name="списокКоэффициентов">список коэффициентов блоков одного канала</param>
        /// <returns>список блоков одного канала для сборки</returns>
        public List<Блок> IDCT(List<short[]> списокКоэффициентов, short[,] матрицаКвантования)
        {
            List<Блок> восстановленныеБлоки = new List<Блок>();
            List<short[,]> матрицыКоэффициентов = new List<short[,]>();
            foreach(short[] коэффициентыБлока in списокКоэффициентов)
            {
                матрицыКоэффициентов.Add(DCT.ОбратныйЗигзаг(коэффициентыБлока));
            }
            //ВосстановлениеDC(матрицыКоэффициентов);
            foreach (short[,] матрицаКоэффициентов in матрицыКоэффициентов)
            {
                DCT.ОбратноеКвантование(матрицаКоэффициентов, матрицаКвантования);
                var блокПослеIDCT = DCT.IDCT(матрицаКоэффициентов);
                Блок восстановленныйБлок = new Блок(DCT.ОбратныйСдвигУровней(блокПослеIDCT));
                восстановленныеБлоки.Add(восстановленныйБлок);
            }
            return восстановленныеБлоки;
        }

        /// <summary>
        /// Конвертирует изображение из формата RGB в формат YUV
        /// </summary>
        /// <param name="изображение">Исходное изображение RGB</param>
        /// <param name="Y">Выходная матрица яркости</param>
        /// <param name="Cb">Выходная матрица цветности</param>
        /// <param name="Cr">Выходная матрица цветности</param>
        public void RGBtoYUV(Точка[,] изображение, out byte[,] Y, out byte[,] Cb, out byte[,] Cr)
        {
            int ширинаИзображения = изображение.GetLength(0);
            int высотаИзображения = изображение.GetLength(1);
            Y = new byte[ширинаИзображения, высотаИзображения];
            Cb = new byte[ширинаИзображения, высотаИзображения];
            Cr = new byte[ширинаИзображения, высотаИзображения];

            for (int j = 0; j < высотаИзображения; j++)
                for (int i = 0; i < ширинаИзображения; i++)
                {
                    byte r = изображение[i, j].r;
                    byte g = изображение[i, j].g;
                    byte b = изображение[i, j].b;
                    Y[i, j] = (byte)Math.Round(0.299000 * r + 0.587000 * g + 0.114000 * b);
                    Cb[i, j] = (byte)Math.Round(-0.168736 * r + -0.331264 * g + 0.500000 * b + 128);
                    Cr[i, j] = (byte)Math.Round(0.500000 * r + -0.418688 * g + -0.081312 * b + 128);
                }
        }

        /// <summary>
        /// Конвертирует изображение из формата YUV в формат RGB
        /// </summary>
        /// <param name="Y">Матрица яркости</param>
        /// <param name="Cb">Матрица цветности</param>
        /// <param name="Cr">Матрица цветности</param>
        /// <returns>Изображение в формате RGB</returns>
        public Точка[,] YUVtoRGB(byte[,] Y, byte[,] Cb, byte[,] Cr)
        {
            int ширинаИзображения = Y.GetLength(0);
            int высотаИзображения = Y.GetLength(1);
            Точка[,] изображениеRGB = new Точка[ширинаИзображения, высотаИзображения];

            for (int j = 0; j < высотаИзображения; j++)
                for (int i = 0; i < ширинаИзображения; i++)
                {
                    byte y = Y[i, j];
                    byte u = Cb[i, j];
                    byte v = Cr[i, j];
                    byte r = (byte)Math.Round(y + 1.4075 * (v - 128));
                    byte g = (byte)Math.Round(y - 0.3455 * (u - 128) - (0.7169 * (v - 128)));
                    byte b = (byte)Math.Round(y + 1.7790 * (u - 128));
                    изображениеRGB[i, j] = new Точка(r, g, b);
                }

            return изображениеRGB;
        }

        /// blocks - список блоков канала, начиная со 2-го блока каждый DC коэффициент должен содержать разницу предыдущим
        /// </summary>
        /// <param name="blocks"></param>
        public void РасчетDC(List<short[,]> blocks)
        {
            int a = 0;
            foreach (short[,] block in blocks)
            {
                if (a != 0)
                {
                    for (int i = 0; i < block.GetLength(1); i++)
                    {
                        for (int j = 0; j < block.GetLength(0); j++)
                        {
                            block[i, j + 1] = (short)(block[i, j + 1] - block[i, j]);
                            if(j+1==7)
                            {
                                 block[i + 1, 0] = (short)(block[i + 1, 0] -  block[i, 7]);
                            }
                        }
                    }  
                }
                a += 1;
            }
        }

        /// <summary>
        /// начиная со 2-го блока восстанавливает первоначальное значение DC коэффициента
        /// </summary>
        /// <param name="blocks"></param>
        public void ВосстановлениеDC(List<short[,]> blocks)
        {
            int a = 0;
            foreach (short[,] block in blocks)
            {
                if (a != 0)
                {
                    int pos = 0;
                    int[] D = new int[block.GetLength(1) * block.GetLength(0)];
                    int K = 0;
                    for (int i = 0; i < block.GetLength(0); i++)
                    {
                        for (int j = 0; j < block.GetLength(1); j++)
                        {
                            D[K] = block[i, j];
                            K++;
                        }
                    }

                    for (int c = 0; c < D.Length - 1; c++)
                    {
                        pos += 1;
                    }

                    for (int c = 0; c < D.Length - 1; c++)
                    {
                        D[pos] = D[pos - 1] + D[pos];
                        pos -= 1;
                    }

                    K = 0;
                    for (int i = 0; i < block.GetLength(0); i++)
                    {
                        for (int j = 0; j < block.GetLength(1); j++)
                        {
                            block[i, j] = (short)D[K];
                            K++;
                        }
                    }
                }
                a += 1;
            }
        }
    }
}
